/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PostWebhookPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/settings/WebhookSettingsTab.ts
var import_obsidian2 = require("obsidian");

// src/settings/components/WebhookItem.ts
var import_obsidian = require("obsidian");
var WebhookItem = class extends import_obsidian.Modal {
  constructor(app, webhook, index, onUpdate, onRemove) {
    super(app);
    this.webhook = webhook;
    this.index = index;
    this.onUpdate = onUpdate;
    this.onRemove = onRemove;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Edit Webhook" });
    new import_obsidian.Setting(contentEl).setName("Webhook Name").setDesc("Enter a name for this Webhook").addText((text) => text.setValue(this.webhook.name).onChange(async (value) => {
      await this.onUpdate(this.index, { name: value });
    }));
    new import_obsidian.Setting(contentEl).setName("Webhook URL").setDesc("Enter the URL for this Webhook").addText((text) => text.setValue(this.webhook.url).onChange(async (value) => {
      await this.onUpdate(this.index, { url: value });
    }));
    new import_obsidian.Setting(contentEl).setName("Response Handling").setDesc("Choose how to handle the Webhook response").addDropdown((dropdown) => {
      dropdown.addOption("none", "Do not use response").addOption("append", "Append to note").addOption("new", "Create new note").addOption("overwrite", "Overwrite note").addOption("ask", "Ask every time").setValue(this.webhook.responseHandling).onChange(async (value) => {
        await this.onUpdate(this.index, {
          responseHandling: value
        });
      });
    });
    new import_obsidian.Setting(contentEl).setName("Process Inline Fields").setDesc("Include inline fields (field:: value) in the webhook payload").addToggle((toggle) => toggle.setValue(this.webhook.processInlineFields || false).onChange(async (value) => {
      await this.onUpdate(this.index, { processInlineFields: value });
    }));
    new import_obsidian.Setting(contentEl).setName("Exclude Attachments").setDesc("Do not send any attachments with this Webhook").addToggle((toggle) => toggle.setValue(this.webhook.excludeAttachments || false).onChange(async (value) => {
      await this.onUpdate(this.index, { excludeAttachments: value });
    }));
    new import_obsidian.Setting(contentEl).setName("Include Webhook context").setDesc("Enable adding another note with context before sending this Webhook").addToggle((toggle) => toggle.setValue(this.webhook.includeVariableNote || false).onChange(async (value) => {
      await this.onUpdate(this.index, { includeVariableNote: value });
    }));
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Remove Webhook").setClass("mod-warning").onClick(async () => {
      await this.onRemove(this.index);
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings/WebhookSettingsTab.ts
var WebhookSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: "Webhooks",
      cls: "mod-top-border"
    });
    const webhooksList = containerEl.createDiv("webhooks-list");
    this.plugin.settings.webhooks.forEach((webhook, index) => {
      const webhookContainer = webhooksList.createDiv("webhook-item");
      webhookContainer.addClass("setting-item");
      const info = webhookContainer.createDiv("setting-item-info");
      const title = info.createDiv("setting-item-name");
      title.setText(webhook.name || "Unnamed Webhook");
      const control = webhookContainer.createDiv("setting-item-control");
      control.style.display = "flex";
      control.style.alignItems = "center";
      control.style.gap = "8px";
      const settingsButton = control.createEl("button", {
        cls: "clickable-icon",
        attr: {
          "aria-label": "Edit webhook settings"
        }
      });
      (0, import_obsidian2.setIcon)(settingsButton, "settings");
      settingsButton.addEventListener("click", (e) => {
        e.stopPropagation();
        this.showWebhookDetails(webhook, index);
      });
      const powerButton = control.createEl("button", {
        cls: "clickable-icon",
        attr: {
          "aria-label": webhook.enabled ? "Disable webhook" : "Enable webhook"
        }
      });
      (0, import_obsidian2.setIcon)(powerButton, "power");
      if (webhook.enabled === void 0 || webhook.enabled) {
        powerButton.addClass("is-enabled");
        powerButton.style.color = "var(--color-green)";
      } else {
        powerButton.addClass("is-disabled");
      }
      powerButton.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.updateWebhook(index, { enabled: !webhook.enabled });
        this.plugin.webhookCommands.registerCommands();
      });
      webhookContainer.addEventListener("click", () => {
        this.showWebhookDetails(webhook, index);
      });
    });
    new import_obsidian2.Setting(containerEl).addButton((button) => button.setButtonText("Add Webhook").onClick(async () => {
      const newWebhook = {
        id: crypto.randomUUID(),
        name: "New Webhook",
        url: "",
        excludeAttachments: false,
        includeVariableNote: false,
        enabled: true,
        processInlineFields: false,
        responseHandling: "append"
      };
      this.plugin.settings.webhooks.push(newWebhook);
      await this.plugin.saveSettings();
      this.showWebhookDetails(newWebhook, this.plugin.settings.webhooks.length - 1);
      this.display();
    }));
  }
  showWebhookDetails(webhook, index) {
    const modal = new WebhookItem(
      this.app,
      webhook,
      index,
      this.updateWebhook.bind(this),
      this.removeWebhook.bind(this)
    );
    modal.open();
  }
  async updateWebhook(index, updates) {
    this.plugin.settings.webhooks[index] = {
      ...this.plugin.settings.webhooks[index],
      ...updates
    };
    await this.plugin.saveSettings();
    this.display();
  }
  async removeWebhook(index) {
    this.plugin.settings.webhooks.splice(index, 1);
    await this.plugin.saveSettings();
    this.display();
  }
};

// src/commands/WebhookCommands.ts
var import_obsidian10 = require("obsidian");

// src/services/WebhookService.ts
var import_obsidian9 = require("obsidian");

// src/services/AttachmentService.ts
var import_obsidian4 = require("obsidian");

// src/utils/MimeTypeUtils.ts
var MimeTypeUtils = class {
  static getMimeType(extension) {
    var _a;
    return this.mimeTypes[(_a = extension == null ? void 0 : extension.toLowerCase()) != null ? _a : ""] || "application/octet-stream";
  }
  static getExtensionFromMimeType(mimeType) {
    for (const [ext, mime] of Object.entries(this.mimeTypes)) {
      if (mimeType.includes(mime))
        return `.${ext}`;
    }
    return ".bin";
  }
};
MimeTypeUtils.mimeTypes = {
  png: "image/png",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  gif: "image/gif",
  webp: "image/webp",
  svg: "image/svg+xml",
  mp3: "audio/mpeg",
  wav: "audio/wav",
  ogg: "audio/ogg",
  m4a: "audio/mp4",
  mp4: "video/mp4",
  webm: "video/webm",
  ogv: "video/ogg",
  mov: "video/quicktime",
  pdf: "application/pdf",
  doc: "application/msword",
  docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  json: "application/json",
  xml: "application/xml",
  zip: "application/zip"
};

// src/utils/YAMLParser.ts
var import_obsidian3 = require("obsidian");
var YAMLParser = class {
  static async getExcludedAttachments(content) {
    try {
      const info = (0, import_obsidian3.getFrontMatterInfo)(content);
      if (!info.exists || !info.frontmatter) {
        return [];
      }
      let frontmatter;
      try {
        frontmatter = (0, import_obsidian3.parseYaml)(info.frontmatter);
      } catch (yamlError) {
        console.warn("Invalid YAML frontmatter:", yamlError);
        return [];
      }
      if (!frontmatter || typeof frontmatter !== "object") {
        return [];
      }
      const excludeAttachment = frontmatter["exclude-attachment"];
      if (!excludeAttachment) {
        return [];
      }
      if (typeof excludeAttachment === "string") {
        return [excludeAttachment];
      }
      if (Array.isArray(excludeAttachment)) {
        return excludeAttachment.filter((item) => typeof item === "string").map((item) => item.trim()).filter(Boolean);
      }
      return [];
    } catch (error) {
      console.error("Error processing frontmatter:", error);
      return [];
    }
  }
  static isValidYaml(content) {
    try {
      const info = (0, import_obsidian3.getFrontMatterInfo)(content);
      if (!info.exists || !info.frontmatter) {
        return true;
      }
      (0, import_obsidian3.parseYaml)(info.frontmatter);
      return true;
    } catch (error) {
      return false;
    }
  }
};

// src/services/AttachmentService.ts
var AttachmentService = class {
  static async getAttachments(app, file, excludeAll = false) {
    if (excludeAll) {
      return [];
    }
    const attachments = [];
    const cache = app.metadataCache.getFileCache(file);
    if (!cache) {
      return attachments;
    }
    const fileContent = await app.vault.read(file);
    const excludeList = await YAMLParser.getExcludedAttachments(fileContent);
    await this.processEmbeds(app, file, cache.embeds, excludeList, attachments);
    return attachments;
  }
  static async processEmbeds(app, file, embeds, excludeList, attachments) {
    if (!embeds)
      return;
    for (const embed of embeds) {
      if (!embed.link)
        continue;
      const linkedFile = app.metadataCache.getFirstLinkpathDest(embed.link, file.path);
      if (!linkedFile || !(linkedFile instanceof import_obsidian4.TFile) || excludeList.includes(linkedFile.name)) {
        continue;
      }
      const attachment = await this.processAttachment(app, linkedFile);
      if (attachment) {
        attachments.push(attachment);
      }
    }
  }
  static async processAttachment(app, file) {
    try {
      const arrayBuffer = await app.vault.readBinary(file);
      const base64Data = (0, import_obsidian4.arrayBufferToBase64)(arrayBuffer);
      const extension = file.extension.toLowerCase();
      const mimeType = MimeTypeUtils.getMimeType(extension);
      return {
        name: file.name,
        type: extension,
        mimeType,
        size: arrayBuffer.byteLength,
        data: base64Data,
        path: file.path
      };
    } catch (error) {
      console.error(`Failed to process attachment ${file.name}:`, error);
      return null;
    }
  }
};

// src/services/PayloadService.ts
var import_obsidian5 = require("obsidian");
var PayloadService = class {
  static createPayload(content, filename, attachments, selectedText, variableNote, processInlineFields = false) {
    const info = (0, import_obsidian5.getFrontMatterInfo)(content);
    let payload;
    if (!info.exists) {
      payload = {
        content: selectedText || content,
        filename,
        timestamp: Date.now(),
        attachments
      };
    } else {
      const frontmatter = (0, import_obsidian5.parseYaml)(info.frontmatter);
      const noteContent = selectedText || content.slice(info.contentStart).trim();
      payload = {
        ...frontmatter,
        content: noteContent,
        filename,
        timestamp: Date.now(),
        attachments
      };
    }
    if (processInlineFields) {
      const inlineFields = this.extractInlineFields(selectedText || content);
      payload = {
        ...payload,
        ...inlineFields
      };
    }
    if (variableNote == null ? void 0 : variableNote.variables) {
      payload = {
        ...payload,
        ...variableNote.variables
      };
    }
    return payload;
  }
  static extractInlineFields(content) {
    const fields = {};
    const inlineFieldRegex = /^([^:\n]+)::([^\n]+)$/gm;
    let match;
    while ((match = inlineFieldRegex.exec(content)) !== null) {
      const [, key, value] = match;
      const trimmedKey = key.trim();
      const trimmedValue = value.trim();
      if (trimmedValue.startsWith("[") && trimmedValue.endsWith("]")) {
        const arrayValue = trimmedValue.slice(1, -1).split(",").map((item) => item.trim()).filter((item) => item.length > 0);
        if (Array.isArray(fields[trimmedKey])) {
          fields[trimmedKey].push(...arrayValue);
        } else if (fields[trimmedKey]) {
          fields[trimmedKey] = [fields[trimmedKey], ...arrayValue];
        } else {
          fields[trimmedKey] = arrayValue;
        }
      } else {
        if (fields[trimmedKey]) {
          if (Array.isArray(fields[trimmedKey])) {
            fields[trimmedKey].push(trimmedValue);
          } else {
            fields[trimmedKey] = [fields[trimmedKey], trimmedValue];
          }
        } else {
          fields[trimmedKey] = trimmedValue;
        }
      }
    }
    return fields;
  }
};

// src/utils/ContentTypeUtils.ts
var ContentTypeUtils = class {
  static isTextContent(contentType = "") {
    const textTypes = [
      "text/",
      "application/json",
      "application/xml",
      "application/javascript",
      "application/ecmascript",
      "application/x-httpd-php",
      "application/x-yaml"
    ];
    contentType = contentType.toLowerCase();
    return textTypes.some((type) => contentType.includes(type));
  }
};

// src/utils/FileUtils.ts
var FileUtils = class {
  static generateFilename(contentType) {
    const extension = MimeTypeUtils.getExtensionFromMimeType(contentType);
    const timestamp = Date.now();
    return `webhook-response-${timestamp}${extension}`;
  }
};

// src/services/ResponseHandler.ts
var ResponseHandler = class {
  static async processResponse(app, response) {
    var _a, _b;
    const contentType = (((_a = response.headers) == null ? void 0 : _a["content-type"]) || ((_b = response.headers) == null ? void 0 : _b["Content-Type"]) || "").toLowerCase();
    if (contentType.includes("application/json")) {
      return this.formatJsonResponse(response);
    }
    if (ContentTypeUtils.isTextContent(contentType)) {
      return this.formatTextResponse(response);
    }
    return this.processBinaryResponse(app, response, contentType);
  }
  static async handleProcessedResponse(app, response, file, selection, mode) {
    switch (mode) {
      case "append":
        await this.appendResponse(app, response, file, selection);
        break;
      case "new":
        await this.createNewNote(app, response, file);
        break;
      case "overwrite":
        await this.overwriteNote(app, response, file);
        break;
      case "none":
        break;
    }
  }
  static async appendResponse(app, response, file, selection) {
    const content = await app.vault.read(file);
    let newContent;
    if (selection) {
      const selectionIndex = content.indexOf(selection);
      if (selectionIndex !== -1) {
        newContent = content.slice(0, selectionIndex + selection.length) + "\n\n" + response + "\n\n" + content.slice(selectionIndex + selection.length);
      } else {
        newContent = content + "\n\n" + response;
      }
    } else {
      newContent = content + "\n\n" + response;
    }
    await app.vault.modify(file, newContent);
  }
  static async createNewNote(app, response, originalFile) {
    const newName = await this.generateNewFileName(app, originalFile);
    await app.vault.create(newName, response);
  }
  static async overwriteNote(app, response, file) {
    await app.vault.modify(file, response);
  }
  static async generateNewFileName(app, file) {
    const basePath = file.path.substring(0, file.path.lastIndexOf("/") + 1);
    let baseName = file.basename;
    const extension = file.extension;
    const versionRegex = / v(\d+)$/;
    const match = baseName.match(versionRegex);
    let version = 1;
    if (match) {
      version = parseInt(match[1]) + 1;
      baseName = baseName.replace(versionRegex, "");
    }
    let finalName = "";
    let exists = true;
    while (exists) {
      finalName = `${basePath}${baseName} v${version}.${extension}`;
      exists = await app.vault.adapter.exists(finalName);
      version++;
    }
    return finalName;
  }
  static async formatJsonResponse(response) {
    try {
      const jsonData = await response.json;
      return "```json\n" + JSON.stringify(jsonData, null, 2) + "\n```";
    } catch (error) {
      console.error("Failed to parse JSON response:", error);
      return "Failed to parse JSON response";
    }
  }
  static async formatTextResponse(response) {
    try {
      return await response.text;
    } catch (error) {
      console.error("Failed to get text response:", error);
      return "Failed to get text response";
    }
  }
  static async processBinaryResponse(app, response, contentType) {
    var _a;
    try {
      const buffer = await response.arrayBuffer;
      const filename = FileUtils.generateFilename(contentType);
      const attachmentFolder = ((_a = app.vault.config) == null ? void 0 : _a.attachmentFolderPath) || "attachments";
      try {
        await app.vault.createFolder(attachmentFolder);
      } catch (error) {
      }
      const file = await app.vault.createBinary(
        `${attachmentFolder}/${filename}`,
        buffer
      );
      return `![[${file.name}]]`;
    } catch (error) {
      console.error("Failed to process binary response:", error);
      return "Failed to process binary response";
    }
  }
};

// src/utils/UrlUtils.ts
var UrlUtils = class {
  static validateUrl(url) {
    try {
      const parsedUrl = new URL(url);
      return parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:";
    } catch (e) {
      return false;
    }
  }
};

// src/ui/VariableNoteModal.ts
var import_obsidian7 = require("obsidian");

// src/services/VariableNoteService.ts
var VariableNoteService = class {
  static async findVariableNotes(vault, metadataCache) {
    const notes = [];
    const markdownFiles = vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const metadata = metadataCache.getFileCache(file);
      const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
      if ((frontmatter == null ? void 0 : frontmatter["post-webhook"]) === true) {
        const content = await vault.read(file);
        const variables = this.parseVariables(content);
        notes.push({
          title: file.basename,
          path: file.path,
          variables
        });
      }
    }
    return notes;
  }
  static parseVariables(content) {
    const variables = {};
    const lines = content.split("\n");
    let currentKey = null;
    let currentValue = [];
    for (const line of lines) {
      const match = line.match(/^--([\w_]+)/);
      if (match) {
        if (currentKey) {
          variables[currentKey] = currentValue.join("\n").trim();
          currentValue = [];
        }
        currentKey = match[1];
      } else if (currentKey) {
        currentValue.push(line);
      }
    }
    if (currentKey) {
      variables[currentKey] = currentValue.join("\n").trim();
    }
    return variables;
  }
};

// src/ui/components/VariableNoteSuggester.ts
var import_obsidian6 = require("obsidian");
var VariableNoteSuggester = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, notes, onChoose) {
    super(app);
    this.notes = notes;
    this.onChoose = onChoose;
  }
  getItems() {
    return this.notes;
  }
  getItemText(item) {
    return item.title;
  }
  onChooseItem(item) {
    this.onChoose(item);
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.item.title });
    el.createEl("small", { text: item.item.path });
  }
};

// src/ui/VariableNoteModal.ts
var VariableNoteModal = class extends import_obsidian7.Modal {
  constructor(app, onSubmit, onCancel) {
    super(app);
    this.notes = [];
    this.selectedNote = null;
    this.wasSubmitted = false;
    this.onSubmit = onSubmit;
    this.onCancel = onCancel;
  }
  async onOpen() {
    try {
      this.notes = await VariableNoteService.findVariableNotes(this.app.vault, this.app.metadataCache);
      if (this.notes.length === 0) {
        this.contentEl.createEl("div", { text: "No context notes found. Add post-webhook: true to note frontmatter." });
        return;
      }
      this.wasSubmitted = true;
      this.close();
      new VariableNoteSuggester(
        this.app,
        this.notes,
        (note) => {
          this.selectedNote = note;
          this.onSubmit(note);
        }
      ).open();
    } catch (error) {
      this.contentEl.createEl("div", { text: "Error loading context notes." });
      console.error("Error loading context notes:", error);
    }
  }
  onClose() {
    if (!this.wasSubmitted) {
      this.onCancel();
    }
    this.contentEl.empty();
  }
};

// src/ui/ResponseHandlingModal.ts
var import_obsidian8 = require("obsidian");
var ResponseHandlingModal = class extends import_obsidian8.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.mode = "append";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Response Handling" });
    new import_obsidian8.Setting(contentEl).setName("Mode").setDesc("Choose how to handle the response").addDropdown((dropdown) => {
      dropdown.addOption("append", "Append to note").addOption("new", "Create new note").addOption("overwrite", "Overwrite note").setValue(this.mode).onChange((value) => {
        this.mode = value;
      });
    });
    new import_obsidian8.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => {
      this.onSubmit(this.mode, false);
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/services/WebhookService.ts
var WebhookService = class {
  static async sendContent(app, webhookUrl, content, filename, file, selectedText) {
    if (!webhookUrl) {
      throw new Error("Webhook URL is required");
    }
    if (!UrlUtils.validateUrl(webhookUrl)) {
      throw new Error("Invalid Webhook URL. Must be a valid HTTP or HTTPS URL");
    }
    try {
      const plugin = app.plugins.plugins["post-webhook"];
      const webhook = plugin == null ? void 0 : plugin.settings.webhooks.find((w) => w.url === webhookUrl);
      let variableNote = null;
      if (webhook == null ? void 0 : webhook.includeVariableNote) {
        variableNote = await new Promise((resolve) => {
          new VariableNoteModal(
            app,
            (note) => resolve(note),
            () => resolve(null)
          ).open();
        });
        if (!variableNote) {
          throw new Error("Variable note selection cancelled");
        }
      }
      const attachments = await AttachmentService.getAttachments(app, file, webhook == null ? void 0 : webhook.excludeAttachments);
      if (!selectedText) {
        const activeView = app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (activeView == null ? void 0 : activeView.editor) {
          selectedText = activeView.editor.getSelection();
        }
      }
      const payload = PayloadService.createPayload(
        content,
        filename,
        attachments,
        selectedText,
        variableNote,
        (webhook == null ? void 0 : webhook.processInlineFields) || false
      );
      const response = await (0, import_obsidian9.requestUrl)({
        url: webhookUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        body: JSON.stringify(payload)
      });
      if (response.status >= 400) {
        throw new Error(`Request failed: ${response.status}`);
      }
      const processedResponse = await ResponseHandler.processResponse(app, response);
      if (webhook == null ? void 0 : webhook.responseHandling) {
        let mode = webhook.responseHandling;
        if (mode === "ask") {
          const modalResult = await new Promise((resolve) => {
            new ResponseHandlingModal(app, (mode2, dontAskAgain) => {
              resolve({ mode: mode2, dontAskAgain });
            }).open();
          });
          mode = modalResult.mode;
          if (modalResult.dontAskAgain) {
            webhook.responseHandling = mode;
            await plugin.saveSettings();
          }
        }
        await ResponseHandler.handleProcessedResponse(app, processedResponse, file, selectedText || null, mode);
      }
      return {
        status: response.status,
        text: processedResponse
      };
    } catch (error) {
      if (error.message === "Variable note selection cancelled") {
        throw error;
      }
      if (error.message.includes("Failed to fetch")) {
        throw new Error("Could not connect to the Webhook URL. Please check your internet connection and the URL");
      }
      throw new Error(`Failed to send Webhook: ${error.message}`);
    }
  }
};

// src/commands/WebhookCommands.ts
var WebhookCommands = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.registeredCommands = /* @__PURE__ */ new Set();
  }
  registerCommands() {
    this.unregisterCommands();
    this.plugin.settings.webhooks.forEach((webhook) => {
      if (webhook.enabled === false) {
        return;
      }
      const noteCommandId = `post-webhook-note-${webhook.id}`;
      this.plugin.addCommand({
        id: noteCommandId,
        name: `Send note to ${webhook.name}`,
        callback: async () => {
          const activeFile = this.plugin.app.workspace.getActiveFile();
          if (!activeFile) {
            new import_obsidian10.Notice("No active file");
            return;
          }
          try {
            const content = await this.plugin.app.vault.read(activeFile);
            await WebhookService.sendContent(
              this.plugin.app,
              webhook.url,
              content,
              activeFile.name,
              activeFile
            );
            new import_obsidian10.Notice(`Note sent to ${webhook.name}`);
          } catch (error) {
            new import_obsidian10.Notice(`Failed to send note: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
      });
      this.registeredCommands.add(noteCommandId);
      const selectionCommandId = `post-webhook-selection-${webhook.id}`;
      this.plugin.addCommand({
        id: selectionCommandId,
        name: `Send selection to ${webhook.name}`,
        editorCallback: async (editor, view) => {
          const activeFile = view.file;
          if (!activeFile) {
            new import_obsidian10.Notice("No active file");
            return;
          }
          const selection = editor.getSelection();
          if (!selection) {
            new import_obsidian10.Notice("No text selected");
            return;
          }
          try {
            const content = await this.plugin.app.vault.read(activeFile);
            await WebhookService.sendContent(
              this.plugin.app,
              webhook.url,
              content,
              activeFile.name,
              activeFile,
              selection
            );
            new import_obsidian10.Notice(`Selection sent to ${webhook.name}`);
          } catch (error) {
            new import_obsidian10.Notice(`Failed to send selection: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
      });
      this.registeredCommands.add(selectionCommandId);
    });
  }
  unregisterCommands() {
    this.registeredCommands.forEach((commandId) => {
      const commands = this.plugin.app.commands;
      if (commands && commands.removeCommand) {
        commands.removeCommand(commandId);
      }
    });
    this.registeredCommands.clear();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  webhooks: [{
    id: crypto.randomUUID(),
    name: "Default Webhook",
    url: "",
    enabled: true,
    processInlineFields: false,
    responseHandling: "append"
  }]
};
var PostWebhookPlugin = class extends import_obsidian11.Plugin {
  async onload() {
    await this.loadSettings();
    this.webhookCommands = new WebhookCommands(this);
    this.webhookCommands.registerCommands();
    this.addSettingTab(new WebhookSettingsTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settings.webhooks = this.settings.webhooks.map((webhook) => {
      var _a, _b;
      return {
        ...webhook,
        // For old webhooks with id 'default' or no id, generate a new UUID
        id: webhook.id === "default" || !webhook.id ? crypto.randomUUID() : webhook.id,
        enabled: (_a = webhook.enabled) != null ? _a : true,
        processInlineFields: (_b = webhook.processInlineFields) != null ? _b : false,
        responseHandling: webhook.responseHandling || "append"
      };
    });
  }
  async saveSettings() {
    var _a;
    await this.saveData(this.settings);
    (_a = this.webhookCommands) == null ? void 0 : _a.registerCommands();
  }
};


/* nosourcemap */